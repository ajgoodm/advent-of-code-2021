pub mod solutions {
    use std::{collections::HashMap};

    use itertools::Itertools;

    use crate::{AocBufReader};



    struct QueuedInsertion {
        idx: usize,
        char: char
    }

    pub struct Polymer {
        template: String,
        insertions: HashMap<String, char>
    }


    impl Polymer {
        fn len(&self) -> usize {
            self.template.len()
        }

        fn insert_char_at(&mut self, idx: usize, c: char) {
            if idx > self.len() { panic!("Cannot insert char there!") }
            self.template = vec![&self.template[..idx], &c.to_string(), &self.template[idx..]].iter().join("")
        }

        fn run_insertions(&mut self) {
            let mut insertion_queue: Vec<QueuedInsertion> = vec![];
            for idx in 0usize..self.template.len() - 1 {
                match self.insertions.get(&self.template[idx..idx + 2]) {
                    Some(c) => insertion_queue.push(
                        QueuedInsertion {
                            idx: idx + 1 + insertion_queue.len(),
                            char: *c
                        }
                    ),
                    None => ()
                }
            }

            for queued_insertion in insertion_queue.iter() {
                self.insert_char_at(queued_insertion.idx, queued_insertion.char)
            }
        }


        fn score(&self) -> usize {
            let mut occurence_count: HashMap<char, usize> = HashMap::new();
            for c in self.template.chars() {
                *occurence_count.entry(c).or_insert(0) += 1
            }

            let mut max_char_val: usize = usize::MIN;
            let mut min_char_val: usize = usize::MAX;

            for (c, cts) in occurence_count {
                if cts > max_char_val {max_char_val = cts}
                if cts < min_char_val {min_char_val = cts}
            }
            max_char_val - min_char_val
        }
    }


    struct PolymerPt2 {
        bichars: HashMap<String, usize>,
        insertions: HashMap<String, char>,
        last_char: char,
    }


    // The strategy of modeling the polymer does scale well (exponentially with iteration)
    // Similar to the last O(exp(n)) problem, we can model populations that evolve
    // independently. In this problem, the populations are bicharacters, all substrings of
    // the template of length 2.
    impl PolymerPt2 {
        fn run_insertions(&mut self) {
            let mut additions: HashMap<String, usize> = HashMap::new();
            for (bichar, c) in &self.insertions {
                let first_char = bichar.as_bytes()[0] as char;
                let second_char = bichar.as_bytes()[1] as char;

                let str1: String = vec![first_char, *c].iter().collect();
                let str2: String = vec![*c, second_char].iter().collect();

                let mitoses: usize;
                match self.bichars.get(bichar) {
                    Some(val) => mitoses = *val,
                    None => mitoses = 0
                }
                // every instance of the matched bicharacter mitoses into the two generated strings
                // for AB -> C, a single AB will decompose into AC, and CB
                // The counts of AC and CB will increase by the number of AB occurences.
                *additions.entry(str1).or_insert(0) += mitoses;
                *additions.entry(str2).or_insert(0) += mitoses;
 
                // All AB's will decompose (some may be regenerated by other insertions)
                self.bichars.insert(bichar.to_string(), 0);
            }

            for (bichar, val) in additions {
                *self.bichars.entry(bichar).or_insert(0) += val;
            }
        }

        fn score(&self) -> usize {
            let mut occurence_count: HashMap<char, usize> = HashMap::new();
            for (bichar, ct) in &self.bichars {
                let first_char = bichar.as_bytes()[0] as char;
                *occurence_count.entry(first_char).or_insert(0) += ct
            }
            // to not double count, only consider the first character of all
            // substrings length 2.
            // Special case the very last character, which is not the first
            // character of any length 2 substring.
            *occurence_count.entry(self.last_char).or_insert(0) += 1;

            let mut max_char_val: usize = usize::MIN;
            let mut min_char_val: usize = usize::MAX;

            for (c, cts) in occurence_count {
                if cts > max_char_val {max_char_val = cts}
                if cts < min_char_val {min_char_val = cts}
            }
            max_char_val - min_char_val
        }
    }


    fn read_input_pt1(mut aoc_reader: AocBufReader) -> Polymer {
        let mut polymer = Polymer {
            template: aoc_reader.next().unwrap(),
            insertions: HashMap::new()
        };

        aoc_reader.next().unwrap(); // blank line
        let mut insertion_rules: HashMap<String, char> = HashMap::new();
        while let Some(line) = aoc_reader.next() {
            let inputs: Vec<&str> = line.split(" -> ").collect();
            let pair = inputs[0];
            assert_eq!(pair.len(), 2);

            let new_element = inputs[1];
            assert_eq!(new_element.len(), 1);

            insertion_rules.insert(pair.to_string(), new_element.as_bytes()[0] as char);
        }
        polymer.insertions = insertion_rules;
        polymer
    }


    pub fn part_1(aoc_reader: AocBufReader) -> usize {
        let mut polymer = read_input_pt1(aoc_reader);
        for _ in 0..10 {
            polymer.run_insertions();
        }
        polymer.score()
    }


    fn read_input_pt2(mut aoc_reader: AocBufReader) -> PolymerPt2 {
        let mut bichars: HashMap<String, usize> = HashMap::new();
        let template = aoc_reader.next().unwrap();
        for idx in 0..(template.len() - 1) {
            *bichars.entry(template[idx..idx + 2].to_string()).or_insert(0) += 1;
        }


        aoc_reader.next().unwrap(); // blank line
        let mut insertion_rules: HashMap<String, char> = HashMap::new();
        while let Some(line) = aoc_reader.next() {
            let inputs: Vec<&str> = line.split(" -> ").collect();
            let pair = inputs[0];
            assert_eq!(pair.len(), 2);

            let new_element = inputs[1];
            assert_eq!(new_element.len(), 1);

            insertion_rules.insert(pair.to_string(), new_element.as_bytes()[0] as char);
        }
        PolymerPt2 { bichars: bichars, insertions: insertion_rules, last_char: template.chars().last().unwrap() }
    }


    pub fn part_2(aoc_reader: AocBufReader) -> usize {
        let mut polymer = read_input_pt2(aoc_reader);
        for _ in 0..40 {
            polymer.run_insertions();
        }
        polymer.score()
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_insert_char_at() {
            let mut test_seq: Polymer = Polymer {template: "ABC".to_string(), insertions: HashMap::new()};
            test_seq.insert_char_at(0, 'D');
            assert_eq!(test_seq.template, "DABC".to_string());
            test_seq.insert_char_at(1, 'E');
            assert_eq!(test_seq.template, "DEABC".to_string());
            test_seq.insert_char_at(test_seq.len(), 'F');
            assert_eq!(test_seq.template, "DEABCF".to_string());
        }

        #[test]
        fn test_run_insertions() {
            let mut test_seq: Polymer = Polymer {
                template: "NNCB".to_string(),
                insertions: vec![
                    ("NN".to_string(), 'C'),
                    ("NC".to_string(), 'B'),
                    ("CB".to_string(), 'H')
                ].into_iter().collect()
            };
            test_seq.run_insertions();
            assert_eq!(test_seq.template, "NCNBCHB".to_string());
        }
    }
}
